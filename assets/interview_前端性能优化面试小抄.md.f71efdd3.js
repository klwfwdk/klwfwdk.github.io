import{_ as e,o as s,c as o,O as n,z as a,a as l}from"./chunks/framework.d98a00e9.js";const q=JSON.parse('{"title":"前端性能优化面试小抄","description":"","frontmatter":{"title":"前端性能优化面试小抄","date":"2022-01-03T00:00:00.000Z","tags":["性能优化"],"categories":["面试总结"],"recommend":2},"headers":[],"relativePath":"interview/前端性能优化面试小抄.md","filePath":"interview/前端性能优化面试小抄.md","lastUpdated":1683220251000}'),t={name:"interview/前端性能优化面试小抄.md"},i=n(`<h1 id="前端性能优化" tabindex="-1">前端性能优化 <a class="header-anchor" href="#前端性能优化" aria-label="Permalink to &quot;前端性能优化&quot;">​</a></h1><blockquote><p><a href="https://alienzhou.com/projects/fe-performance-journey/" target="_blank" rel="noreferrer">参考博客</a></p></blockquote><h2 id="使用缓存" tabindex="-1">使用缓存 <a class="header-anchor" href="#使用缓存" aria-label="Permalink to &quot;使用缓存&quot;">​</a></h2><p>缓存的总结见 <a href="./temp.html">缓存</a></p><h2 id="发送请求" tabindex="-1">发送请求 <a class="header-anchor" href="#发送请求" aria-label="Permalink to &quot;发送请求&quot;">​</a></h2><ol><li>避免重定向滥用</li><li>DNS 预解析 <code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//yourwebsite.com&quot;&gt;</code></li><li>预链接 Preconnect <code>&lt;link rel=&quot;preconnect&quot; href=&quot;//sample.com&quot; crossorigin&gt;</code>,crossorigin视情况而定。</li><li>静态资源走cdn</li></ol><h2 id="页面解析" tabindex="-1">页面解析 <a class="header-anchor" href="#页面解析" aria-label="Permalink to &quot;页面解析&quot;">​</a></h2><h3 id="防止js阻塞dom的解析-css阻塞js" tabindex="-1">防止js阻塞dom的解析，css阻塞js <a class="header-anchor" href="#防止js阻塞dom的解析-css阻塞js" aria-label="Permalink to &quot;防止js阻塞dom的解析，css阻塞js&quot;">​</a></h3><p>JavaScript 会阻塞 DOM 构建，而 CSSOM 的构建又会阻塞 JavaScript 的执行。所以一般来说建议把 CSS 样式表放在<code>&lt;head&gt;</code>之中（即页面的头部），把 JavaScript 脚本放在<code>&lt;body&gt;</code>的最后（即页面的尾部）。 除了上述方法 可以通过<code>script defer</code>或者 <code>script async</code> 两者都可以让script加载时不阻塞页面的解析。不同的是 defer 会在 HTML 解析完成后，按照脚本出现的次序再顺序执行；而 async 则是下载完成就立即开始执行，同时阻塞页面解析，不保证脚本间的执行顺序。</p><h3 id="压缩html" tabindex="-1">压缩HTML <a class="header-anchor" href="#压缩html" aria-label="Permalink to &quot;压缩HTML&quot;">​</a></h3><p>HTML 的文档大小也会极大影响响应体下载的时间。一般会进行 HTML 内容压缩（uglify）的同时，使用文本压缩算法（例如 gzip）进行文本的压缩。关于资源压缩这一块，在下一节的内容中还会再详细进行介绍。</p><h2 id="页面静态资源" tabindex="-1">页面静态资源 <a class="header-anchor" href="#页面静态资源" aria-label="Permalink to &quot;页面静态资源&quot;">​</a></h2><h3 id="js" tabindex="-1">js <a class="header-anchor" href="#js" aria-label="Permalink to &quot;js&quot;">​</a></h3><ol><li>代码合并，代码拆分，并按需加载</li><li>代码压缩，tree shaking，优化polyfill，优化webpack体积</li><li>谨慎使用框架，在部分场景下不使用vue等框架</li><li>利用缓存，将不经常变动的代码抽出来单独打包，比如框架代码，避免缓存失效</li><li>强缓存加hash</li><li>拆分 runtime chunk</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// webpack.config.js</span></span>
<span class="line"><span style="color:#89DDFF;">module.exports</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//...</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">optimization</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#F07178;">runtimeChunk</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">runtime</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><ol start="7"><li>使用 records</li></ol><h3 id="css" tabindex="-1">CSS <a class="header-anchor" href="#css" aria-label="Permalink to &quot;CSS&quot;">​</a></h3><ol><li>关键渲染路径（Critical Rendering Path，即 CRP），骨架屏</li><li>优化资源请求</li><li>压缩和选择合适的兼容性</li><li>简化选择器</li><li>避免使用昂贵的属性</li></ol><blockquote><p>border-radius; box-shadow; opacity; transform; filter; position: fixed;</p></blockquote><ol start="6"><li>利用缓存</li></ol><h3 id="图片" tabindex="-1">图片 <a class="header-anchor" href="#图片" aria-label="Permalink to &quot;图片&quot;">​</a></h3><ol><li>雪碧图</li><li>懒加载</li><li>选择合适的图片格式 svg，gif用视频代替</li><li>渐进式加载</li><li>压缩并选择合适的分辨率和质量</li><li>删除原信息</li><li>缓存</li></ol><h2 id="运行时" tabindex="-1">运行时 <a class="header-anchor" href="#运行时" aria-label="Permalink to &quot;运行时&quot;">​</a></h2>`,23),r=a("ol",null,[a("li",null,"虚拟滚动"),a("li",null,[l("避免 JavaScript 运行时间过长 "),a("ol",null,[a("li",null,"分散到多帧执行 requestAnimationFrame"),a("li",null,"空闲时执行 requestIdleCallback"),a("li",null,"并行计算 webworker")])]),a("li",null,"使用 composite 3d加速 css相关"),a("li",null,"对滚动等事件进行防抖或者节流"),a("li",{"passive:":"",true:""},"针对不影响页面滚动的事件监听使用")],-1),c=a("h2",{id:"预加载",tabindex:"-1"},[l("预加载 "),a("a",{class:"header-anchor",href:"#预加载","aria-label":'Permalink to "预加载"'},"​")],-1),p=a("ol",null,[a("li",null,"prefetch 低优先级"),a("li",null,"preload 高优先级"),a("li",null,"prerender 预渲染")],-1),d=[i,r,c,p];function h(u,m,_,D,y,f){return s(),o("div",null,d)}const C=e(t,[["render",h]]);export{q as __pageData,C as default};

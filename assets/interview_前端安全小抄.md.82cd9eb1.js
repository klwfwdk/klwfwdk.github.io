import{_ as e,o as i,c as l,O as a}from"./chunks/framework.d98a00e9.js";const S=JSON.parse('{"title":"前端安全面试小抄","description":"","frontmatter":{"title":"前端安全面试小抄","date":"2022-01-09T00:00:00.000Z","recommend":1,"tags":["安全"],"categories":["面试总结"]},"headers":[],"relativePath":"interview/前端安全小抄.md","filePath":"interview/前端安全小抄.md","lastUpdated":1683220251000}'),o={name:"interview/前端安全小抄.md"},t=a('<h1 id="前端安全面试小抄" tabindex="-1">前端安全面试小抄 <a class="header-anchor" href="#前端安全面试小抄" aria-label="Permalink to &quot;前端安全面试小抄&quot;">​</a></h1><blockquote><p>参考内容</p><p><a href="https://juejin.cn/post/6844903842635579405#heading-1" target="_blank" rel="noreferrer">【面试篇】寒冬求职之你必须要懂的Web安全</a></p><p><a href="https://zhuanlan.zhihu.com/p/130946490" target="_blank" rel="noreferrer">什么是HSTS，为什么要使用它？</a></p><p><a href="https://insights.thoughtworks.cn/eight-security-problems-in-front-end/" target="_blank" rel="noreferrer">8大前端安全问题</a></p></blockquote><h2 id="前端安全类型" tabindex="-1">前端安全类型 <a class="header-anchor" href="#前端安全类型" aria-label="Permalink to &quot;前端安全类型&quot;">​</a></h2><ol><li>XSS 跨站脚本攻击</li><li>CSRF 跨站请求伪造</li><li>Clickjacking 点击劫持</li><li>MIME 类型混淆攻击(&quot;X-Content-Type-Options: nosniff&quot;)</li><li>第三方包漏洞</li><li>HTTPS强制降级</li><li>本地数据泄漏（不要存储关键信息到本地）</li><li>CDN劫持</li></ol><h2 id="xss-跨站脚本攻击" tabindex="-1">XSS 跨站脚本攻击 <a class="header-anchor" href="#xss-跨站脚本攻击" aria-label="Permalink to &quot;XSS 跨站脚本攻击&quot;">​</a></h2><p>XSS(cross-site scripting，跨站脚本攻击)是一种代码注入攻击。攻击者将在网站上注入恶意代码，当被攻击者登陆登陆网站时就会执行这些恶意代码。存在的危害有</p><ol><li>读取cookie session token等敏感信息</li><li>钓鱼</li><li>蠕虫攻击</li></ol><p>其本质是恶意代码未经过过滤，与正常的代码混在一起被浏览器执行了。而浏览器无法区分两者的来源从而获得了更高的权限。</p><p>按照攻击的来源分为三类</p><ol><li>反射型</li><li>储存型</li><li>DOM型</li></ol><h3 id="反射型" tabindex="-1">反射型 <a class="header-anchor" href="#反射型" aria-label="Permalink to &quot;反射型&quot;">​</a></h3><p>攻击步骤如下:</p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 如上述操作可以推出，这类攻击常见于网站搜索，跳转等特殊场景。需要用户主动打开恶意URL才能生效。也可能通过构造表单提交页面引导用户点击对post请求进行反射式XSS。 解决方案为对url查询对参数进行转译后再输出到页面</li></ol><h3 id="储存型" tabindex="-1">储存型 <a class="header-anchor" href="#储存型" aria-label="Permalink to &quot;储存型&quot;">​</a></h3><p>储存型常见于博客或者点评页面。用户通过提交带有恶意代码的内容到服务器，然后通过服务器渲染时在被攻击者的电脑上运行恶意代码 解决方案为在用户提交内容的时候进行转义</p><h3 id="dom型" tabindex="-1">dom型 <a class="header-anchor" href="#dom型" aria-label="Permalink to &quot;dom型&quot;">​</a></h3><p>dom型其实在前后端分离的今天，跟储存型很类似，只是一个入库，一个不入库。防范方式也类似，只是前两种可由后端进行处理。而dom型只能够由前端进行处理。</p><h3 id="防范方式" tabindex="-1">防范方式 <a class="header-anchor" href="#防范方式" aria-label="Permalink to &quot;防范方式&quot;">​</a></h3><p>除了转译还有以下方式进行防范</p><ol><li>设置严格的csp(content-security-policy，内容安全策略)，有以下好处 <ol><li>禁止加载外域代码，防止复杂的攻击逻辑。</li><li>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。</li><li>禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。</li><li>禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。</li><li>合理使用上报可以及时发现 XSS，利于尽快修复问题。</li></ol></li><li>限制输入内容的长度</li><li>限制输入内容，比如只能是数字活着不能包含特殊字符</li><li>HTTP-only Cookie，禁止js读取敏感的cookie</li></ol><h2 id="csrf-cross-site-request-forgery-跨站请求伪造" tabindex="-1">CSRF (cross-site request forgery) 跨站请求伪造 <a class="header-anchor" href="#csrf-cross-site-request-forgery-跨站请求伪造" aria-label="Permalink to &quot;CSRF (cross-site request forgery) 跨站请求伪造&quot;">​</a></h2><p>攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><p>攻击流程如下</p><ol><li>受害者登录A站点，并保留了登录凭证（Cookie）。</li><li>攻击者诱导受害者访问了站点B。</li><li>站点B向站点A发送了一个请求，为了避免跨域一般是form请求，浏览器会默认携带站点A的Cookie信息。</li><li>站点A接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是无辜的受害者发送的请求。</li><li>站点A以受害者的名义执行了站点B的请求。</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者完成了攻击。</li></ol><blockquote><p>一个域名下的js 未经允许不能读取另一个域名的内容，但是浏览器不会阻止你向另一个域名发请求</p></blockquote><h3 id="防范方式-1" tabindex="-1">防范方式 <a class="header-anchor" href="#防范方式-1" aria-label="Permalink to &quot;防范方式&quot;">​</a></h3><ol><li>添加验证码，防止请求的自动发送</li><li>检测Refere，但是这个字段可以被伪造</li><li>使用Token，而不是cookie。</li><li>Samesite cookie <ol><li>在设置cookie的时候通过<code>Samesite</code>属性可以防止B伪造请求带上自己的cookie，但是存在兼容性问题。</li><li>这个字段可以为<code>Strict</code>,所有请求都无法获取cookie，可以为<code>Lax</code>，这样的话GET OPTIONS HEAD可以 其他不行。</li></ol></li></ol><h2 id="点击劫持" tabindex="-1">点击劫持 <a class="header-anchor" href="#点击劫持" aria-label="Permalink to &quot;点击劫持&quot;">​</a></h2><p>点击劫持是在网页中隐藏一个透明的iframe， 用外层假页面诱导用户点击，但是是在隐藏的页面上触发了点击事件产生的用户不知情的操作。</p><p>防范方式，核心就一条： 阻止页面在不同源的页面中加载。</p><ol><li>frame busting，用人话说就是在网页中判断自己的location和top的是否同源 同源就进行破坏</li><li>X-Frame-Options: 设置页面在iframe下是否允许加载。 <ol><li>DENY: 禁止所有</li><li>SAMEORIGIN: 允许同源加载</li><li>ALLOW-FROM: 可以自定义允许的页面地址</li></ol></li></ol><h2 id="https强制降级-然后进行中间人攻击" tabindex="-1">HTTPS强制降级，然后进行中间人攻击 <a class="header-anchor" href="#https强制降级-然后进行中间人攻击" aria-label="Permalink to &quot;HTTPS强制降级，然后进行中间人攻击&quot;">​</a></h2><p>就算是使用了HTTPS,攻击者通过特殊手段进行了降级，然后进行中间人攻击。一般为了向下兼容，我们会通过重定向将http的请求转到https上。但是在攻击者存在时，通过特殊手段阻止了这次重定向结果拦截了，并且代替客户端和服务器端进行后续的通信。 解决方案是通过设置<code>HSTS</code></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Strict-Transport-Security: max-age=31536000; includeSubDomains; preload</span></span></code></pre></div><p>意思是每个链接到此域和其子域的请求 在 <code>max-age</code>秒内，只能给被https链接，任何使用http加载资源的请求，都必须使用https进行替代。如果https不可用，则必须停止链接。 这个方法有两个问题，一个是如果证书失效会导致页面完全无法被访问，第二个是第一次访问不收到保护，如果一开始中间人就存在，HSTS响应头也可以被修改，所以不可信。</p><p>针对第一次 有个备用方法，就是由google组织的HSTS preload list。开发者可以在配置好HSTS后去 <a href="https://hstspreload.org/" target="_blank" rel="noreferrer">https://hstspreload.org/</a> 添加自己的域名。这个列表会被所有主流浏览器硬编码到浏览器程序内，所以设置以后生效和失效都需要较长的时间。</p>',36),r=[t];function s(n,c,h,p,d,u){return i(),l("div",null,r)}const f=e(o,[["render",s]]);export{S as __pageData,f as default};
